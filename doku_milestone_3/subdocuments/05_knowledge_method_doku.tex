\documentclass[main.tex]{subfiles}

\begin{document}

	\begingroup

	\renewcommand{\cleardoublepage}{}

	\renewcommand{\clearpage}{}

	\chapter{Knowledge Function Documentation}

		\chapterauthor{Jeremias Thun}

All the Information about the existing surfaces and the objects are managed in our Knowledgebase. Every question about the relationship between these Objects as well as which one should be taken next and where should it be put is answerd by this Knowledgebase. The Knowledgebase is built as part of KnowRob. All data is stored as RDF triple, organized by an OWL ontology. This is where logical relationship between the category of objects and surfaces is implemented. 
		
\section{Knowledgebase}
\chapterauthor{Jeremias Thun}

\subsection{object\_state.pl}

First of all, we need to add some objects that we can work on to our Knowledgebase. This is where the perceived objects go when the Percpetion-Group found something:

\begin{lstlisting}
create_object_at(
	PerceivedObjectType, 
	PercTypeConfidence, 
	Transform, 
	Threshold, 
	Instance, 
	[Width, Depth, Height], 
	Shape, 
	PercShapeConfidence, 
	Color, 
	PercColorCondidence) :-
\end{lstlisting}
This confusingly big predicate takes all the perceived Data, creates a corresponding Object in the Knowledgebase and adds all the attributes. Within this procedure, there are a few verifications and changes made, though: The Class, Shape and Color of the Object all have a probability with which they are correctly perceived. These confidences are stored as link to the Object (more on that in the OWL-Chapter), but only if they satisfy a secified threshold. If they don't, the attributes are set back to default values. Also we check if the given data makes any sence, i.e. if the object has a reasonable size.\\
Besides a few helper predicates, this module also contains two helpful little predicates to get all Objects that are stored at that moment:
\begin{lstlisting}
hsr_existing_objects(Objects) :-
    belief_existing_objects(Objects, [hsr_objects:'Item']).
\end{lstlisting}
And there \texttt{hsr\_forget\_object/1} removes an Object from the beliefstate:
\begin{lstlisting}
hsr_forget_object(Object) :-
    rdf_retractall(Object,_,_).
\end{lstlisting}

\subsection{beliefstate.pl}

In the Belief State mostly all changing information about our Knowledge is managed. Here lie the predicates that are called in \texttt{create\_object\_at/9}. To actually create a new Object in our belief state, there is:
\begin{lstlisting}
new_perceived_at(ObjType, Transform, Threshold, Instance) :-
\begin{lstlisting}
This Module also gives the opportunity to look at a specific Position in the map and ask, whether there already is a known Object and, if so, which one:
\begin{lstlisting}
hsr_existing_object_at(_, Transform, Threshold, Instance) :-
\end{lstlisting}
To determine, whether an object is hard to grasp it is often helpful to know, whether there are other objects right next to it. That is why there is a specific attribute that stores Groups of Objectts. 
\begin{lstlisting}
group_objecs(Objs)
\end{lstlisting}
This Predicate takes a list of Objects and iterates through them to see if there are any groups and create them if necessary.\\
To make it more human-readable, there are also two other predicates that basically just call \texttt{group\_objects} with a different list of Objects:
\begin{lstlisting}
group_shelf_objects/0
group_table_objects/0
\end{lstlisting}

\subsection{pickup.pl}

In the pickup module the information necessary to pick an object up are organized.

\begin{lstlisting}
next_object(BestObj) :-
\end{lstlisting}
As soon as there are some objects stored in our beliefstate, Knowledge is able zu tell, which Object should be the next one, the robot takes and puts somewhere. This prediacte returns the Object, that is standing on a surface, that was previously declared as \texttt{source} surface and is closest to the robot.

\subsection{assignplaces.pl}

Like \texttt{pickup.pl}, this module organizes the information necessary for when an object is placed.\\

In the end, everything Planning needs is given by
\begin{lstlisting}
object_goal_pose_offset(Instance, [[X,Y,Z], Rotation],Context):-
\end{lstlisting}
It takes an Object and returns the pose this object should be placed and as Context it also returns, why this decision was made the way it was.\\
But this predicate actually contains a few other queries. Some of the most important ones are:

\begin{lstlisting}
object_goal_surface(Instance, NearestSurface, Context, Self) :-
\end{lstlisting}
First we need a decision about what surface the object should be placed on. This is simply based on which surface is nearest to the robot and has the attribute of a \texttt{target} surface.
\begin{lstlisting}
most_related_object(Source, Target, Distance) :-
distance_to_object(Source, Target, Distance) :-
\end{lstlisting}

Here lies the decision about what object is most similar to the one, \texttt{object\_goal\_pose\_offset} got. \texttt{distance\_to\_object} can tell, how similar two objects are (what the legical distance between them is) in the class hierarchy. This is based on the knowrob-predicate \texttt{distance\_of/3}. The \texttt{most\_related\_obeject} iterates through every object already in place and either finds a similar one based on similar object-classes or, in case the class of our object is \texttt{Other}, looks for another object that has the same color or size as our object. This is also, where the context, i.e. the human readable reason why the object was placed the way it was, is generated. It tells us, if the decision was based on it's class (if so, how similar they were), on it's size or it's color.

\subsection{surfaces.pl}

The bigges module is the \texttt{surfaces} module. This is where you can find everything you need to know about surfaces.

\subsection{spatial\_comp.pl}



\section{Ontology}
\chapterauthor{Fabian Rosenstock}
\subsection{Robocup}
	  	
	  	The Robocup Ontology defines Concepts used to describe the Robocup and Concepts needed for the URDFs.
	  	
	  	\subsection{Objects}
	  	
	  	This Ontology describes and categorizes different physical objects according to their properties or common uses. These categories help to reason over objects, for example find similar objects. The Ontology furthermore defines different properties objects can have.  
	  	

\section{Scripts and higher Architecture}
\chapterauthor{gfdhjlhkj}	  	
hgfkjh

	\endgroup

\end{document}
