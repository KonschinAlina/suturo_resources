\documentclass[main.tex]{subfiles}

\begin{document}

	\begingroup

	\renewcommand{\cleardoublepage}{}

	\renewcommand{\clearpage}{}

	\chapter{Manipulation Function Documentation}


		\chapterauthor{\vspace{5mm}Marc Stelter, Jan Neumann, Fabian Weihe}
		
		\subsection{General}

		Manipulation has four action servers.\\
		The "move\_gripper\_action\_server" moves the gripper to the given position.\\
		The "take\_pose\_action\_server" moves the robot into perceiving position.\\
		The "grasps\_object\_server" receives the size and position of an object and grasps it.\\
		The "place\_server" places the attached object at the given pose.\\
		Further Manipulation has a "suturo\_manipulation\_launch" package, which launches the action servers, \textit{rviz} and \textit{Giskard} and a "object\_state\_listener" package.
		
		\newpage


		\subsection{move\_gripper\_action\_server} \chapterauthor{Fabian Weihe}
		The Motivation behind the "move\_gripper\_server" was creating a script which can move the Gripper to any position. In contrast to "grasp\_object" the script only moves the gripper without grasping or any orientation.
		Thats the reason why we decided to use the "grasp\_object\_server" for this task instead. So we don't use the "move\_gripper\_server" anymore
		
		\vspace{0.75cm}
		The script receives:
		\begin{itemize}
		 \item PoseStamped goal\_pose
     	\end{itemize} 
     	
     	 \vspace{0,75 cm}
     	 The result can be:
     	\begin{itemize}
     		\item uint8 SUCESS=0
     		\item uint8 FAILED=1
     		\item uint8 error\_code
     	\end{itemize}
     	
     	\vspace{0,75 cm}
     	The Feedback is:
     	\begin{itemize}
     		\item TransformStamped tf\_gripper\_to\_object
     	\end{itemize}
	
		  \vspace{0,75 cm}
		With using \textit{Giskard} the script moves the gripper to the "goal\_pose". After that it checks if the transformation has succeeded and return success or failure as feedback.
		
		\newpage
		\subsection{grasp\_object\_server} \chapterauthor{Fabian Weihe}
		
			The Motivation behind the "grasp\_object\_server" was creating a script which can grasp an object in diverse positions. We made a few tests with the HSR and discover that we can nearly grasp any object either from the top or front. So we decided to differentiate between these two cases. Although we think that it is a good idea to check if the HSR grasped the object and move to a position at the end, where we can comfortable move around.
			
			The script receives: 
			\begin{itemize}
				\item String "object\_frame\_id"
				\item PoseStamped "goal\_pose"
				\item Vector3 "object\_size"
				\item uint8 "grasp\_mode"
			\end{itemize}
			
			\vspace{0,25 cm}
			The "object\_frame\_id" relates to the object we want to grasp.
		
			\vspace{0,25 cm}
			The "goal\_pose" is the position of the object in the map.

			\vspace{0,25 cm}
			"object\_size" contains the size of the object, we want to grasp.
			
			\vspace{0,25 cm}
			The "grasp\_mode" says in which way we want to grasp the object:
			\begin{itemize}
			 \item uint8 FREE=0: we use the given orientation.
			 \item uint8 FRONT=1: grasp the object frontal.
			 \item uint8 TOP=2: grasp the object from the top
			 \item uint8 JUST=3: just close the gripper with transport pose.
			 \end{itemize}
			 \vspace{0,75 cm}
			 The result can be:
			 \begin{itemize}
			 	\item uint8 SUCESS=0
			 	\item uint8 FAILED=1
			 	\item uint8 error\_code
			 \end{itemize}
		 
			\vspace{0,75 cm}
			The Feedback is:
			\begin{itemize}
				\item TransformStamped tf\_gripper\_to\_object
				\item float64 gripper\_joint\_state
			\end{itemize}
			 
			 \vspace{0,75 cm}
			 The first method "get\_current\_joint\_state"  sets the value of every slider to its corresponding current joint state.
			 
			 \vspace{0,25 cm}
			 "execute\_cb" is the first method which is called, when the server receives a new goal. Based on which "grasp\_mode" is chosen the method either calls "grasp\_to\_position" or "just\_grasp". The only case where "just\_grasp" is called is in "grasp\_mode" 3 ("JUST").
			 
			 \vspace{0,25 cm}
			 In every other case "grasp\_to\_position" is called.\\
			In the first step, the method opens the gripper to the maximum. After that, the arm is moved to the object. The "grasp\_mode" determines if the object should be grasped from the front, the top, or a free given orientation. When the arm has moved to the given position "goal\_pose", the script closes the gripper. In the end, the grasped object given by "object\_frame\_id" is added in \textit{Giskard} and attached to the robot. After that the method "move\_to\_transport\_pose" is called.\\
			Finally, it checks if the object is in the gripper and returns whether the action has failed or succeeded.
			
			\vspace{0,25 cm}
			The method "just\_grasp" move to the transport pose, opens the gripper, wait 3 seconds, and close the gripper. Finally, it checks if the object is in the gripper.
			
			\vspace{0,25 cm}
			The method "move\_to\_transport\_pose" transform the robot in a position, where it can comfortably move around.
			
			\vspace{0,25 cm}
			The last method "object\_in\_gripper" checks if the robot hold something in the gripper and returns a boolean.\\
			
			\section{take\_pose\_server.py} \chapterauthor{Jan Neumann}
			
			The Take\_Pose\_Server puts the HSR into a pose to perceive objects depending on the chosen pose\_mode. \\
			In FREE mode the server puts the HSR into a pose given by the float joint goals in the message. This is used for testing and error handling in Planning. \\
			In NEUTRAL mode the HSR is put into a predefined pose that is used when the HSR is transporting an object. \\
			In LOOK\_LOW, LOOK\_HIGH and LOOK\_FLOOR mode the server puts the HSR into a predefined position that is specifically designed to perceive objects on the tables, shelves, and floor in the HSR lab. The advantage is that this works independently from other parts of the suturo project. The disadvantage is that these modes are not suited to perceive objects on planes that have a different height than the ones specified. \\
			In GAZE mode the server receives a Vector 3 gaze\_point which represents the coordinates of the middle of a plane that the HSR is supposed to perceive objects on. The server then calculates the height and direction for the camera to perceive objects on the given plane and puts the HSR into the resulting pose.
			
			\begin{itemize}
				\item Input: TakePoseGoal 
				\subitem uint8 pose\_mode
				\subsubitem FREE=0
				\subsubitem NEUTRAL=1
				\subsubitem LOOK\_LOW=2
				\subsubitem LOOK\_HIGH=3
				\subsubitem LOOK\_FLOOR=4
				\subsubitem GAZE=5
				\subitem geometry\_msgs/Vector3 gaze\_point
				\subitem float32 head\_pan\_joint
				\subitem float32 head\_tilt\_joint
				\subitem float32 arm\_lift\_joint
				\subitem float32 arm\_flex\_joint
				\subitem float32 arm\_roll\_joint
				\subitem float32 wrist\_flex\_joint
				\subitem float32 wrist\_roll\_joint
				\item Return: TakePoseResult
				\subitem uint8 error\_code 
				\subsubitem SUCCESS=0
				\subsubitem FAILED=1
			\end{itemize}
			
			
			\section{place\_server.py}  \chapterauthor{Marc Stelter}
			Places the object in the gripper at the given position. Depending on the place\_mode the orientation of the gripper is calculated. Giskard is then used to move the gripper to the given position. If \textit{Giskard} was successful and the gripper is at the correct position the object is released and the robot returns into a neutral pose. In the case of an error, the Object will not be released and the robot finishes in a neutral position. 
			
			\begin{itemize}
				\item Input: PlaceActionGoal 
				\subitem string object\_frame\_id 
				\subitem geometry\_msgs/PoseStamped goal\_pose
				\subitem place\_mode
				\item Return: PlaceActionResult
				\subitem int error\_code (0 success, else failure)
			\end{itemize}
			
			\section{object\_state\_listener.py} \chapterauthor{Marc Stelter}
			Adds, modifies, or removes objects from the \textit{Giskard} environment believe state.
			
			\begin{itemize}
				\item Topic: /object\_state
				\item Input: knowrob\_objects/ObjectStateArray
				\item Methods:
				\subitem def delete\_object(self, object\_state\_array): removes the objects
				\subitem def add\_object(self, object\_state\_array): adds or modifies the objects
				\subitem def object\_state\_callback(self, object\_state\_array): processes a new ObjectStateArray message
			\end{itemize}
			
			\section{\textit{Giskard}\_load\_static\_objects.py} \chapterauthor{Marc Stelter}
			The simple script meant to be run once at startup. It loads the environment from the parameter server and adds it to \textit{Giskards} believe state. 
			The script can be run again to reload the environment. The old environment will automatically be removed.
			
			 
			\section{int\_testmarker}
			A small node creating an interactive marker allowing easy testing of manipulation in \textit{rviz}. The marker is a simple box. The box can be dragged around in the 3D room. A right-click on the marker opens a menu giving the option to take a pose, grasp, or place at the position of the marker. The pose of the marker in the map is shown in the description of the marker. In order to show the updated position the description needs to be disabled and enabled again.
			\begin{itemize}
				\item Topic: int\_test\_marker\_manipulation
			\end{itemize}

			
	\endgroup

\end{document}


